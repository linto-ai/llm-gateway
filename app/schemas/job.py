"""Job Pydantic schemas."""
from pydantic import BaseModel, Field, UUID4
from typing import Optional, Any, Literal, List
from datetime import datetime


# Pass types for processing
PassType = Literal["initial", "continuation", "reduce", "summary", "single_pass", "extraction", "categorization"]

# Processing phases
ProcessingPhase = Literal["processing", "reducing", "generating_document"]


class JobPassMetrics(BaseModel):
    """Metrics for a single processing pass."""

    pass_number: int = Field(..., ge=1, description="1-indexed pass number")
    pass_type: PassType = Field(..., description="Type of processing pass")
    started_at: datetime = Field(..., description="When the pass started")
    completed_at: Optional[datetime] = Field(None, description="When the pass completed (null if in progress)")
    duration_ms: int = Field(..., ge=0, description="Processing time in milliseconds")

    # Token breakdown
    prompt_tokens: int = Field(..., ge=0, description="Tokens in the prompt")
    completion_tokens: int = Field(..., ge=0, description="Tokens generated by the model")
    total_tokens: int = Field(..., ge=0, description="Total tokens (prompt + completion)")

    # Content metrics
    input_chars: int = Field(..., ge=0, description="Characters sent to model")
    output_chars: int = Field(..., ge=0, description="Characters received from model")

    # Cost tracking
    estimated_cost: Optional[float] = Field(None, description="USD estimate based on model pricing")


class JobTokenMetrics(BaseModel):
    """Aggregated token metrics for a job across all passes."""

    # Per-pass breakdown
    passes: List[JobPassMetrics] = Field(default_factory=list, description="Metrics for each processing pass")

    # Cumulative totals
    total_prompt_tokens: int = Field(0, ge=0, description="Total prompt tokens across all passes")
    total_completion_tokens: int = Field(0, ge=0, description="Total completion tokens across all passes")
    total_tokens: int = Field(0, ge=0, description="Total tokens across all passes")
    total_duration_ms: int = Field(0, ge=0, description="Total processing duration in milliseconds")
    total_estimated_cost: Optional[float] = Field(None, description="Total estimated cost in USD")

    # Averages
    avg_tokens_per_pass: float = Field(0.0, description="Average tokens per pass")
    avg_duration_per_pass_ms: float = Field(0.0, description="Average duration per pass in milliseconds")


class CurrentPassMetrics(BaseModel):
    """Lightweight metrics for current pass in WebSocket updates."""

    pass_number: int = Field(..., ge=1)
    pass_type: str
    prompt_tokens: int = Field(..., ge=0)
    completion_tokens: int = Field(..., ge=0)
    duration_ms: int = Field(..., ge=0)


class CumulativeMetrics(BaseModel):
    """Cumulative metrics for WebSocket updates."""

    total_tokens: int = Field(0, ge=0)
    total_prompt_tokens: int = Field(0, ge=0)
    total_completion_tokens: int = Field(0, ge=0)
    total_duration_ms: int = Field(0, ge=0)
    total_estimated_cost: Optional[float] = None


class RetryInfo(BaseModel):
    """Information about retry attempts."""

    attempt: int = Field(..., ge=1, description="Current attempt number (1 = first try)")
    max_attempts: int = Field(..., ge=1, description="Maximum attempts configured")
    delay_seconds: Optional[float] = Field(None, description="Delay before next retry")
    error_type: Optional[str] = Field(None, description="Type of error that triggered retry")
    error_message: Optional[str] = Field(None, description="Error message from failed attempt")


class JobProgress(BaseModel):
    """Job progress tracking with enhanced fields."""

    current: int = Field(..., ge=0)
    total: int = Field(..., gt=0)
    percentage: float = Field(..., ge=0, le=100)

    # Enhanced progress fields
    phase: Optional[ProcessingPhase] = Field(
        "processing",
        description="Current processing phase: processing (main), reducing (post-iteration), generating_document (title generation)"
    )
    current_batch: int = 0
    total_batches: int = 1
    completed_turns: int = 0
    total_turns: int = 0
    estimated_seconds_remaining: Optional[int] = None

    # Retry tracking
    retry_info: Optional[RetryInfo] = Field(None, description="Current retry state if retrying")
    total_retries: int = Field(0, description="Total retries so far in this job")


class JobUpdate(BaseModel):
    """
    WebSocket message format for real-time job status updates.

    Sent by the server to connected WebSocket clients when job state changes.

    Event types:
    - status_change: Job status changed (queued -> started -> processing -> completed/failed)
    - progress: Processing progress update
    - retry: LLM API call is being retried
    - error: Non-fatal error occurred (job continues)
    - complete: Job finished (success or failure)
    """

    job_id: str
    event_type: Literal['status_change', 'progress', 'retry', 'error', 'complete'] = 'status_change'
    status: Literal['queued', 'started', 'processing', 'completed', 'failed', 'cancelled']
    progress: Optional[JobProgress] = None
    result: Optional[Any] = None
    error: Optional[str] = None
    error_code: Optional[str] = Field(None, description="Machine-readable error code")
    retry_info: Optional[RetryInfo] = Field(None, description="Retry details when event_type=retry")
    timestamp: str

    # Live metrics in WebSocket updates
    current_pass_metrics: Optional[CurrentPassMetrics] = Field(
        None, description="Metrics for the current processing pass"
    )
    cumulative_metrics: Optional[CumulativeMetrics] = Field(
        None, description="Cumulative token metrics across all passes"
    )


class JobResponse(BaseModel):
    """Job response schema."""

    id: UUID4
    service_id: UUID4
    service_name: str
    flavor_id: Optional[UUID4] = None
    flavor_name: str
    status: str
    created_at: datetime
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    result: Optional[Any] = None
    error: Optional[str] = None
    progress: Optional[JobProgress] = None
    # Free-form organization identifier (any string up to 100 chars)
    organization_id: Optional[str] = None

    # Fallback tracking fields
    fallback_applied: bool = Field(
        default=False,
        description="Whether fallback was triggered due to context overflow"
    )
    original_flavor_id: Optional[UUID4] = Field(
        None,
        description="Original flavor ID before fallback"
    )
    original_flavor_name: Optional[str] = Field(
        None,
        description="Original flavor name before fallback"
    )
    fallback_reason: Optional[str] = Field(
        None,
        description="Reason for fallback (e.g., 'Input (X tokens) exceeds context limit (Y available)')"
    )
    input_tokens: Optional[int] = Field(
        None,
        description="Number of input tokens that triggered fallback"
    )
    context_available: Optional[int] = Field(
        None,
        description="Context window available before fallback"
    )

    # Token metrics
    token_metrics: Optional[JobTokenMetrics] = Field(
        None, description="Token usage and processing metrics"
    )

    # Output type from flavor configuration
    output_type: str = Field(
        default="text",
        description="Output format type from flavor (text, markdown, json, structured)"
    )

    # Version tracking
    current_version: int = Field(
        default=1,
        description="Current version number (default 1)"
    )
    last_edited_at: Optional[datetime] = Field(
        None,
        description="ISO datetime of last edit"
    )

    # Metadata extraction capability
    has_extraction_prompt: bool = Field(
        default=False,
        description="Whether the flavor has an extraction prompt configured"
    )

    # Processing mode from flavor configuration
    processing_mode: str = Field(
        default="iterative",
        description="Processing mode: single_pass or iterative"
    )

    class Config:
        from_attributes = True


class JobFinalSummary(BaseModel):
    """Summary metrics for completed jobs."""

    total_tokens: int = Field(..., ge=0)
    total_duration_ms: int = Field(..., ge=0)
    total_passes: int = Field(..., ge=0)
    total_estimated_cost: Optional[float] = None


class JobMetricsResponse(BaseModel):
    """Response for dedicated job metrics endpoint."""

    job_id: str
    status: str
    token_metrics: Optional[JobTokenMetrics] = None
    final_summary: Optional[JobFinalSummary] = Field(
        None, description="Only populated for completed jobs"
    )


class ExecuteServiceRequest(BaseModel):
    """Request schema for service execution."""

    flavor_id: UUID4
    temperature: Optional[float] = Field(None, ge=0, le=2)
    top_p: Optional[float] = Field(None, ge=0, le=1)
    # Free-form organization identifier (any string up to 100 chars)
    organization_id: Optional[str] = None


class ExecuteServiceResponse(BaseModel):
    """Response schema for service execution."""

    job_id: UUID4
    message: str = "Job queued successfully"


class JobCancelResponse(BaseModel):
    """Response schema for job cancellation."""

    job_id: UUID4
    status: Literal["cancelled", "failed"]
    message: str


class JobResultUpdate(BaseModel):
    """Request schema for updating job result content."""

    content: str = Field(..., min_length=1, description="New result content (required)")


class JobVersionSummary(BaseModel):
    """Summary information for a job result version."""

    version_number: int = Field(..., description="1 = original, 2+ = edits")
    created_at: datetime = Field(..., description="When this version was created")
    created_by: Optional[str] = Field(None, description="User identifier")
    content_length: int = Field(..., description="Character count at that version")


class JobVersionDetail(BaseModel):
    """Detailed information for a specific job result version."""

    version_number: int = Field(..., description="1 = original, 2+ = edits")
    created_at: datetime = Field(..., description="When this version was created")
    created_by: Optional[str] = Field(None, description="User identifier")
    content: str = Field(..., description="Full reconstructed content")


# Global Jobs WebSocket schemas

class ActiveJobSnapshot(BaseModel):
    """Snapshot of an active job for WebSocket broadcast."""

    job_id: str
    status: str
    progress: Optional[JobProgress] = None
    service_name: Optional[str] = None
    flavor_name: Optional[str] = None
    created_at: Optional[datetime] = None


class JobsSnapshotMessage(BaseModel):
    """Initial snapshot of all active jobs."""

    type: Literal["jobs_snapshot"] = "jobs_snapshot"
    jobs: List[ActiveJobSnapshot]
    timestamp: datetime


class JobUpdateBroadcast(BaseModel):
    """Individual job update for broadcast."""

    type: Literal["job_update"] = "job_update"
    job_id: str
    status: str
    progress: Optional[JobProgress] = None
    result: Optional[Any] = None
    error: Optional[str] = None
    timestamp: datetime
